import units.qual.*;

package java.util.concurrent;

class AbstractExecutorService implements ExecutorService {
    AbstractExecutorService();
    protected <T> RunnableFuture<T> newTaskFor(Runnable arg0, T arg1);
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> arg0);
    Future<?> submit(Runnable arg0);
    <T> Future<T> submit(Runnable arg0, T arg1);
    <T> Future<T> submit(Callable<T> arg0);
    <T> T invokeAny(Collection<? extends Callable<T>> arg0) throws InterruptedException,ExecutionException;
    <T> T invokeAny(Collection<? extends Callable<T>> arg0, long arg1, TimeUnit arg2) throws InterruptedException,ExecutionException,TimeoutException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> arg0) throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> arg0, long arg1, TimeUnit arg2) throws InterruptedException;
}

class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
    ArrayBlockingQueue(int arg0);
    ArrayBlockingQueue(int arg0, boolean arg1);
    ArrayBlockingQueue(int arg0, boolean arg1, Collection<? extends E> arg2);
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E poll();
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E peek();
    int size();
    int remainingCapacity();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    String toString();
    void clear();
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
    Iterator<E> iterator();
    Spliterator<E> spliterator();
}

interface BlockingDeque<E> extends BlockingQueue<E>, Deque<E> {
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    void putFirst(E arg0) throws InterruptedException;
    void putLast(E arg0) throws InterruptedException;
    boolean offerFirst(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    boolean offerLast(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E takeFirst() throws InterruptedException;
    E takeLast() throws InterruptedException;
    E pollFirst(long arg0, TimeUnit arg1) throws InterruptedException;
    E pollLast(long arg0, TimeUnit arg1) throws InterruptedException;
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E remove();
    E poll();
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E element();
    E peek();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    int size();
    Iterator<E> iterator();
    void push(E arg0);
}

interface BlockingQueue<E> extends Queue<E> {
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    int remainingCapacity();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
}

class BrokenBarrierException extends Exception {
    BrokenBarrierException();
    BrokenBarrierException(String arg0);
}

interface Callable<V> {
    V call() throws Exception;
}

class CancellationException extends IllegalStateException {
    CancellationException();
    CancellationException(String arg0);
}

class CompletableFuture<T> implements Future<T>, CompletionStage<T> {
    CompletableFuture();
    static <U> CompletableFuture<U> supplyAsync(Supplier<U> arg0);
    static <U> CompletableFuture<U> supplyAsync(Supplier<U> arg0, Executor arg1);
    static CompletableFuture<Void> runAsync(Runnable arg0);
    static CompletableFuture<Void> runAsync(Runnable arg0, Executor arg1);
    static <U> CompletableFuture<U> completedFuture(U arg0);
    boolean isDone();
    T get() throws InterruptedException,ExecutionException;
    T get(long arg0, TimeUnit arg1) throws InterruptedException,ExecutionException,TimeoutException;
    T join();
    T getNow(T arg0);
    boolean complete(T arg0);
    boolean completeExceptionally(Throwable arg0);
    <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> arg0);
    <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> arg0);
    <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> arg0, Executor arg1);
    CompletableFuture<Void> thenAccept(Consumer<? super T> arg0);
    CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> arg0);
    CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> arg0, Executor arg1);
    CompletableFuture<Void> thenRun(Runnable arg0);
    CompletableFuture<Void> thenRunAsync(Runnable arg0);
    CompletableFuture<Void> thenRunAsync(Runnable arg0, Executor arg1);
    <U, V> CompletableFuture<V> thenCombine(CompletionStage<? extends U> arg0, BiFunction<? super T,? super U,? extends V> arg1);
    <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> arg0, BiFunction<? super T,? super U,? extends V> arg1);
    <U, V> CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> arg0, BiFunction<? super T,? super U,? extends V> arg1, Executor arg2);
    <U> CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> arg0, BiConsumer<? super T,? super U> arg1);
    <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> arg0, BiConsumer<? super T,? super U> arg1);
    <U> CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> arg0, BiConsumer<? super T,? super U> arg1, Executor arg2);
    CompletableFuture<Void> runAfterBoth(CompletionStage<?> arg0, Runnable arg1);
    CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> arg0, Runnable arg1);
    CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> arg0, Runnable arg1, Executor arg2);
    <U> CompletableFuture<U> applyToEither(CompletionStage<? extends T> arg0, Function<? super T,U> arg1);
    <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> arg0, Function<? super T,U> arg1);
    <U> CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> arg0, Function<? super T,U> arg1, Executor arg2);
    CompletableFuture<Void> acceptEither(CompletionStage<? extends T> arg0, Consumer<? super T> arg1);
    CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> arg0, Consumer<? super T> arg1);
    CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> arg0, Consumer<? super T> arg1, Executor arg2);
    CompletableFuture<Void> runAfterEither(CompletionStage<?> arg0, Runnable arg1);
    CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> arg0, Runnable arg1);
    CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> arg0, Runnable arg1, Executor arg2);
    <U> CompletableFuture<U> thenCompose(Function<? super T,? extends CompletionStage<U>> arg0);
    <U> CompletableFuture<U> thenComposeAsync(Function<? super T,? extends CompletionStage<U>> arg0);
    <U> CompletableFuture<U> thenComposeAsync(Function<? super T,? extends CompletionStage<U>> arg0, Executor arg1);
    CompletableFuture<T> whenComplete(BiConsumer<? super T,? super Throwable> arg0);
    CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> arg0);
    CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> arg0, Executor arg1);
    <U> CompletableFuture<U> handle(BiFunction<? super T,Throwable,? extends U> arg0);
    <U> CompletableFuture<U> handleAsync(BiFunction<? super T,Throwable,? extends U> arg0);
    <U> CompletableFuture<U> handleAsync(BiFunction<? super T,Throwable,? extends U> arg0, Executor arg1);
    CompletableFuture<T> toCompletableFuture();
    CompletableFuture<T> exceptionally(Function<Throwable,? extends T> arg0);
    static CompletableFuture<Void> allOf(CompletableFuture<?>[] arg0);
    static CompletableFuture<Object> anyOf(CompletableFuture<?>[] arg0);
    boolean cancel(boolean arg0);
    boolean isCancelled();
    boolean isCompletedExceptionally();
    void obtrudeValue(T arg0);
    void obtrudeException(Throwable arg0);
    int getNumberOfDependents();
    String toString();
}
interface CompletableFuture$AsynchronousCompletionTask {
}

class CompletionException extends RuntimeException {
    protected CompletionException();
    protected CompletionException(String arg0);
    CompletionException(String arg0, Throwable arg1);
    CompletionException(Throwable arg0);
}

interface CompletionService<V> {
    Future<V> submit(Callable<V> arg0);
    Future<V> submit(Runnable arg0, V arg1);
    Future<V> take() throws InterruptedException;
    Future<V> poll();
    Future<V> poll(long arg0, TimeUnit arg1) throws InterruptedException;
}

interface CompletionStage<T> {
    <U> CompletionStage<U> thenApply(Function<? super T,? extends U> arg0);
    <U> CompletionStage<U> thenApplyAsync(Function<? super T,? extends U> arg0);
    <U> CompletionStage<U> thenApplyAsync(Function<? super T,? extends U> arg0, Executor arg1);
    CompletionStage<Void> thenAccept(Consumer<? super T> arg0);
    CompletionStage<Void> thenAcceptAsync(Consumer<? super T> arg0);
    CompletionStage<Void> thenAcceptAsync(Consumer<? super T> arg0, Executor arg1);
    CompletionStage<Void> thenRun(Runnable arg0);
    CompletionStage<Void> thenRunAsync(Runnable arg0);
    CompletionStage<Void> thenRunAsync(Runnable arg0, Executor arg1);
    <U, V> CompletionStage<V> thenCombine(CompletionStage<? extends U> arg0, BiFunction<? super T,? super U,? extends V> arg1);
    <U, V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> arg0, BiFunction<? super T,? super U,? extends V> arg1);
    <U, V> CompletionStage<V> thenCombineAsync(CompletionStage<? extends U> arg0, BiFunction<? super T,? super U,? extends V> arg1, Executor arg2);
    <U> CompletionStage<Void> thenAcceptBoth(CompletionStage<? extends U> arg0, BiConsumer<? super T,? super U> arg1);
    <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage<? extends U> arg0, BiConsumer<? super T,? super U> arg1);
    <U> CompletionStage<Void> thenAcceptBothAsync(CompletionStage<? extends U> arg0, BiConsumer<? super T,? super U> arg1, Executor arg2);
    CompletionStage<Void> runAfterBoth(CompletionStage<?> arg0, Runnable arg1);
    CompletionStage<Void> runAfterBothAsync(CompletionStage<?> arg0, Runnable arg1);
    CompletionStage<Void> runAfterBothAsync(CompletionStage<?> arg0, Runnable arg1, Executor arg2);
    <U> CompletionStage<U> applyToEither(CompletionStage<? extends T> arg0, Function<? super T,U> arg1);
    <U> CompletionStage<U> applyToEitherAsync(CompletionStage<? extends T> arg0, Function<? super T,U> arg1);
    <U> CompletionStage<U> applyToEitherAsync(CompletionStage<? extends T> arg0, Function<? super T,U> arg1, Executor arg2);
    CompletionStage<Void> acceptEither(CompletionStage<? extends T> arg0, Consumer<? super T> arg1);
    CompletionStage<Void> acceptEitherAsync(CompletionStage<? extends T> arg0, Consumer<? super T> arg1);
    CompletionStage<Void> acceptEitherAsync(CompletionStage<? extends T> arg0, Consumer<? super T> arg1, Executor arg2);
    CompletionStage<Void> runAfterEither(CompletionStage<?> arg0, Runnable arg1);
    CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> arg0, Runnable arg1);
    CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> arg0, Runnable arg1, Executor arg2);
    <U> CompletionStage<U> thenCompose(Function<? super T,? extends CompletionStage<U>> arg0);
    <U> CompletionStage<U> thenComposeAsync(Function<? super T,? extends CompletionStage<U>> arg0);
    <U> CompletionStage<U> thenComposeAsync(Function<? super T,? extends CompletionStage<U>> arg0, Executor arg1);
    CompletionStage<T> exceptionally(Function<Throwable,? extends T> arg0);
    CompletionStage<T> whenComplete(BiConsumer<? super T,? super Throwable> arg0);
    CompletionStage<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> arg0);
    CompletionStage<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> arg0, Executor arg1);
    <U> CompletionStage<U> handle(BiFunction<? super T,Throwable,? extends U> arg0);
    <U> CompletionStage<U> handleAsync(BiFunction<? super T,Throwable,? extends U> arg0);
    <U> CompletionStage<U> handleAsync(BiFunction<? super T,Throwable,? extends U> arg0, Executor arg1);
    CompletableFuture<T> toCompletableFuture();
}

class ConcurrentHashMap<K, V> extends AbstractMap<K,V> implements ConcurrentMap<K,V>, Serializable {
    ConcurrentHashMap();
    ConcurrentHashMap(int arg0);
    ConcurrentHashMap(Map<? extends K,? extends V> arg0);
    ConcurrentHashMap(int arg0, float arg1);
    ConcurrentHashMap(int arg0, float arg1, int arg2);
    int size();
    boolean isEmpty();
    V get(Object arg0);
    boolean containsKey(Object arg0);
    boolean containsValue(Object arg0);
    V put(K arg0, V arg1);
    void putAll(Map<? extends K,? extends V> arg0);
    V remove(Object arg0);
    void clear();
    KeySetView<K,V> keySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
    int hashCode();
    String toString();
    boolean equals(Object arg0);
    V putIfAbsent(K arg0, V arg1);
    boolean remove(Object arg0, Object arg1);
    boolean replace(K arg0, V arg1, V arg2);
    V replace(K arg0, V arg1);
    V getOrDefault(Object arg0, V arg1);
    void forEach(BiConsumer<? super K,? super V> arg0);
    void replaceAll(BiFunction<? super K,? super V,? extends V> arg0);
    V computeIfAbsent(K arg0, Function<? super K,? extends V> arg1);
    V computeIfPresent(K arg0, BiFunction<? super K,? super V,? extends V> arg1);
    V compute(K arg0, BiFunction<? super K,? super V,? extends V> arg1);
    V merge(K arg0, V arg1, BiFunction<? super V,? super V,? extends V> arg2);
    boolean contains(Object arg0);
    Enumeration<K> keys();
    Enumeration<V> elements();
    long mappingCount();
    static <K> KeySetView<K,Boolean> newKeySet();
    static <K> KeySetView<K,Boolean> newKeySet(int arg0);
    KeySetView<K,V> keySet(V arg0);
    void forEach(long arg0, BiConsumer<? super K,? super V> arg1);
    <U> void forEach(long arg0, BiFunction<? super K,? super V,? extends U> arg1, Consumer<? super U> arg2);
    <U> U search(long arg0, BiFunction<? super K,? super V,? extends U> arg1);
    <U> U reduce(long arg0, BiFunction<? super K,? super V,? extends U> arg1, BiFunction<? super U,? super U,? extends U> arg2);
    double reduceToDouble(long arg0, ToDoubleBiFunction<? super K,? super V> arg1, double arg2, DoubleBinaryOperator arg3);
    long reduceToLong(long arg0, ToLongBiFunction<? super K,? super V> arg1, long arg2, LongBinaryOperator arg3);
    int reduceToInt(long arg0, ToIntBiFunction<? super K,? super V> arg1, int arg2, IntBinaryOperator arg3);
    void forEachKey(long arg0, Consumer<? super K> arg1);
    <U> void forEachKey(long arg0, Function<? super K,? extends U> arg1, Consumer<? super U> arg2);
    <U> U searchKeys(long arg0, Function<? super K,? extends U> arg1);
    K reduceKeys(long arg0, BiFunction<? super K,? super K,? extends K> arg1);
    <U> U reduceKeys(long arg0, Function<? super K,? extends U> arg1, BiFunction<? super U,? super U,? extends U> arg2);
    double reduceKeysToDouble(long arg0, ToDoubleFunction<? super K> arg1, double arg2, DoubleBinaryOperator arg3);
    long reduceKeysToLong(long arg0, ToLongFunction<? super K> arg1, long arg2, LongBinaryOperator arg3);
    int reduceKeysToInt(long arg0, ToIntFunction<? super K> arg1, int arg2, IntBinaryOperator arg3);
    void forEachValue(long arg0, Consumer<? super V> arg1);
    <U> void forEachValue(long arg0, Function<? super V,? extends U> arg1, Consumer<? super U> arg2);
    <U> U searchValues(long arg0, Function<? super V,? extends U> arg1);
    V reduceValues(long arg0, BiFunction<? super V,? super V,? extends V> arg1);
    <U> U reduceValues(long arg0, Function<? super V,? extends U> arg1, BiFunction<? super U,? super U,? extends U> arg2);
    double reduceValuesToDouble(long arg0, ToDoubleFunction<? super V> arg1, double arg2, DoubleBinaryOperator arg3);
    long reduceValuesToLong(long arg0, ToLongFunction<? super V> arg1, long arg2, LongBinaryOperator arg3);
    int reduceValuesToInt(long arg0, ToIntFunction<? super V> arg1, int arg2, IntBinaryOperator arg3);
    void forEachEntry(long arg0, Consumer<? super Entry<K,V>> arg1);
    <U> void forEachEntry(long arg0, Function<Entry<K,V>,? extends U> arg1, Consumer<? super U> arg2);
    <U> U searchEntries(long arg0, Function<Entry<K,V>,? extends U> arg1);
    Entry<K,V> reduceEntries(long arg0, BiFunction<Entry<K,V>,Entry<K,V>,? extends Entry<K,V>> arg1);
    <U> U reduceEntries(long arg0, Function<Entry<K,V>,? extends U> arg1, BiFunction<? super U,? super U,? extends U> arg2);
    double reduceEntriesToDouble(long arg0, ToDoubleFunction<Entry<K,V>> arg1, double arg2, DoubleBinaryOperator arg3);
    long reduceEntriesToLong(long arg0, ToLongFunction<Entry<K,V>> arg1, long arg2, LongBinaryOperator arg3);
    int reduceEntriesToInt(long arg0, ToIntFunction<Entry<K,V>> arg1, int arg2, IntBinaryOperator arg3);
}
class ConcurrentHashMap$KeySetView<K, V> extends CollectionView<K,V,K> implements Set<K>, Serializable {
    V getMappedValue();
    boolean contains(Object arg0);
    boolean remove(Object arg0);
    Iterator<K> iterator();
    boolean add(K arg0);
    boolean addAll(Collection<? extends K> arg0);
    int hashCode();
    boolean equals(Object arg0);
    Spliterator<K> spliterator();
    void forEach(Consumer<? super K> arg0);
}

class ConcurrentLinkedDeque<E> extends AbstractCollection<E> implements Deque<E>, Serializable {
    ConcurrentLinkedDeque();
    ConcurrentLinkedDeque(Collection<? extends E> arg0);
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    E peekFirst();
    E peekLast();
    E getFirst();
    E getLast();
    E pollFirst();
    E pollLast();
    E removeFirst();
    E removeLast();
    boolean offer(E arg0);
    boolean add(E arg0);
    E poll();
    E peek();
    E remove();
    E pop();
    E element();
    void push(E arg0);
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    boolean contains(Object arg0);
    boolean isEmpty();
    int size();
    boolean remove(Object arg0);
    boolean addAll(Collection<? extends E> arg0);
    void clear();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    Iterator<E> iterator();
    Iterator<E> descendingIterator();
    Spliterator<E> spliterator();
}

class ConcurrentLinkedQueue<E> extends AbstractQueue<E> implements Queue<E>, Serializable {
    ConcurrentLinkedQueue();
    ConcurrentLinkedQueue(Collection<? extends E> arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    E poll();
    E peek();
    boolean isEmpty();
    int size();
    boolean contains(Object arg0);
    boolean remove(Object arg0);
    boolean addAll(Collection<? extends E> arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    Iterator<E> iterator();
    Spliterator<E> spliterator();
}

interface ConcurrentMap<K, V> extends Map<K,V> {
    V getOrDefault(Object arg0, V arg1);
    void forEach(BiConsumer<? super K,? super V> arg0);
    V putIfAbsent(K arg0, V arg1);
    boolean remove(Object arg0, Object arg1);
    boolean replace(K arg0, V arg1, V arg2);
    V replace(K arg0, V arg1);
    void replaceAll(BiFunction<? super K,? super V,? extends V> arg0);
    V computeIfAbsent(K arg0, Function<? super K,? extends V> arg1);
    V computeIfPresent(K arg0, BiFunction<? super K,? super V,? extends V> arg1);
    V compute(K arg0, BiFunction<? super K,? super V,? extends V> arg1);
    V merge(K arg0, V arg1, BiFunction<? super V,? super V,? extends V> arg2);
}

interface ConcurrentNavigableMap<K, V> extends ConcurrentMap<K,V>, NavigableMap<K,V> {
    ConcurrentNavigableMap<K,V> subMap(K arg0, boolean arg1, K arg2, boolean arg3);
    ConcurrentNavigableMap<K,V> headMap(K arg0, boolean arg1);
    ConcurrentNavigableMap<K,V> tailMap(K arg0, boolean arg1);
    ConcurrentNavigableMap<K,V> subMap(K arg0, K arg1);
    ConcurrentNavigableMap<K,V> headMap(K arg0);
    ConcurrentNavigableMap<K,V> tailMap(K arg0);
    ConcurrentNavigableMap<K,V> descendingMap();
    NavigableSet<K> navigableKeySet();
    NavigableSet<K> keySet();
    NavigableSet<K> descendingKeySet();
}

class ConcurrentSkipListMap<K, V> extends AbstractMap<K,V> implements ConcurrentNavigableMap<K,V>, Cloneable, Serializable {
    ConcurrentSkipListMap();
    ConcurrentSkipListMap(Comparator<? super K> arg0);
    ConcurrentSkipListMap(Map<? extends K,? extends V> arg0);
    ConcurrentSkipListMap(SortedMap<K,? extends V> arg0);
    ConcurrentSkipListMap<K,V> clone();
    boolean containsKey(Object arg0);
    V get(Object arg0);
    V getOrDefault(Object arg0, V arg1);
    V put(K arg0, V arg1);
    V remove(Object arg0);
    boolean containsValue(Object arg0);
    int size();
    boolean isEmpty();
    void clear();
    V computeIfAbsent(K arg0, Function<? super K,? extends V> arg1);
    V computeIfPresent(K arg0, BiFunction<? super K,? super V,? extends V> arg1);
    V compute(K arg0, BiFunction<? super K,? super V,? extends V> arg1);
    V merge(K arg0, V arg1, BiFunction<? super V,? super V,? extends V> arg2);
    NavigableSet<K> keySet();
    NavigableSet<K> navigableKeySet();
    Collection<V> values();
    Set<Entry<K,V>> entrySet();
    ConcurrentNavigableMap<K,V> descendingMap();
    NavigableSet<K> descendingKeySet();
    boolean equals(Object arg0);
    V putIfAbsent(K arg0, V arg1);
    boolean remove(Object arg0, Object arg1);
    boolean replace(K arg0, V arg1, V arg2);
    V replace(K arg0, V arg1);
    Comparator<? super K> comparator();
    K firstKey();
    K lastKey();
    ConcurrentNavigableMap<K,V> subMap(K arg0, boolean arg1, K arg2, boolean arg3);
    ConcurrentNavigableMap<K,V> headMap(K arg0, boolean arg1);
    ConcurrentNavigableMap<K,V> tailMap(K arg0, boolean arg1);
    ConcurrentNavigableMap<K,V> subMap(K arg0, K arg1);
    ConcurrentNavigableMap<K,V> headMap(K arg0);
    ConcurrentNavigableMap<K,V> tailMap(K arg0);
    Entry<K,V> lowerEntry(K arg0);
    K lowerKey(K arg0);
    Entry<K,V> floorEntry(K arg0);
    K floorKey(K arg0);
    Entry<K,V> ceilingEntry(K arg0);
    K ceilingKey(K arg0);
    Entry<K,V> higherEntry(K arg0);
    K higherKey(K arg0);
    Entry<K,V> firstEntry();
    Entry<K,V> lastEntry();
    Entry<K,V> pollFirstEntry();
    Entry<K,V> pollLastEntry();
    void forEach(BiConsumer<? super K,? super V> arg0);
    void replaceAll(BiFunction<? super K,? super V,? extends V> arg0);
}

class ConcurrentSkipListSet<E> extends AbstractSet<E> implements NavigableSet<E>, Cloneable, Serializable {
    ConcurrentSkipListSet();
    ConcurrentSkipListSet(Comparator<? super E> arg0);
    ConcurrentSkipListSet(Collection<? extends E> arg0);
    ConcurrentSkipListSet(SortedSet<E> arg0);
    ConcurrentSkipListSet<E> clone();
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    boolean add(E arg0);
    boolean remove(Object arg0);
    void clear();
    Iterator<E> iterator();
    Iterator<E> descendingIterator();
    boolean equals(Object arg0);
    boolean removeAll(Collection<?> arg0);
    E lower(E arg0);
    E floor(E arg0);
    E ceiling(E arg0);
    E higher(E arg0);
    E pollFirst();
    E pollLast();
    Comparator<? super E> comparator();
    E first();
    E last();
    NavigableSet<E> subSet(E arg0, boolean arg1, E arg2, boolean arg3);
    NavigableSet<E> headSet(E arg0, boolean arg1);
    NavigableSet<E> tailSet(E arg0, boolean arg1);
    NavigableSet<E> subSet(E arg0, E arg1);
    NavigableSet<E> headSet(E arg0);
    NavigableSet<E> tailSet(E arg0);
    NavigableSet<E> descendingSet();
    Spliterator<E> spliterator();
}

class CopyOnWriteArrayList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
    CopyOnWriteArrayList();
    CopyOnWriteArrayList(Collection<? extends E> arg0);
    CopyOnWriteArrayList(E[] arg0);
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    int indexOf(Object arg0);
    int indexOf(E arg0, int arg1);
    int lastIndexOf(Object arg0);
    int lastIndexOf(E arg0, int arg1);
    Object clone();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    E get(int arg0);
    E set(int arg0, E arg1);
    boolean add(E arg0);
    void add(int arg0, E arg1);
    E remove(int arg0);
    boolean remove(Object arg0);
    boolean addIfAbsent(E arg0);
    boolean containsAll(Collection<?> arg0);
    boolean removeAll(Collection<?> arg0);
    boolean retainAll(Collection<?> arg0);
    int addAllAbsent(Collection<? extends E> arg0);
    void clear();
    boolean addAll(Collection<? extends E> arg0);
    boolean addAll(int arg0, Collection<? extends E> arg1);
    void forEach(Consumer<? super E> arg0);
    boolean removeIf(Predicate<? super E> arg0);
    void replaceAll(UnaryOperator<E> arg0);
    void sort(Comparator<? super E> arg0);
    String toString();
    boolean equals(Object arg0);
    int hashCode();
    Iterator<E> iterator();
    ListIterator<E> listIterator();
    ListIterator<E> listIterator(int arg0);
    Spliterator<E> spliterator();
    List<E> subList(int arg0, int arg1);
}

class CopyOnWriteArraySet<E> extends AbstractSet<E> implements Serializable {
    CopyOnWriteArraySet();
    CopyOnWriteArraySet(Collection<? extends E> arg0);
    int size();
    boolean isEmpty();
    boolean contains(Object arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    void clear();
    boolean remove(Object arg0);
    boolean add(E arg0);
    boolean containsAll(Collection<?> arg0);
    boolean addAll(Collection<? extends E> arg0);
    boolean removeAll(Collection<?> arg0);
    boolean retainAll(Collection<?> arg0);
    Iterator<E> iterator();
    boolean equals(Object arg0);
    boolean removeIf(Predicate<? super E> arg0);
    void forEach(Consumer<? super E> arg0);
    Spliterator<E> spliterator();
}

class CountDownLatch {
    CountDownLatch(int arg0);
    void await() throws InterruptedException;
    boolean await(long arg0, TimeUnit arg1) throws InterruptedException;
    void countDown();
    long getCount();
    String toString();
}

class CountedCompleter<T> extends ForkJoinTask<T> {
    protected CountedCompleter(CountedCompleter<?> arg0, int arg1);
    protected CountedCompleter(CountedCompleter<?> arg0);
    protected CountedCompleter();
    void compute();
    void onCompletion(CountedCompleter<?> arg0);
    boolean onExceptionalCompletion(Throwable arg0, CountedCompleter<?> arg1);
    CountedCompleter<?> getCompleter();
    int getPendingCount();
    void setPendingCount(int arg0);
    void addToPendingCount(int arg0);
    boolean compareAndSetPendingCount(int arg0, int arg1);
    int decrementPendingCountUnlessZero();
    CountedCompleter<?> getRoot();
    void tryComplete();
    void propagateCompletion();
    void complete(T arg0);
    CountedCompleter<?> firstComplete();
    CountedCompleter<?> nextComplete();
    void quietlyCompleteRoot();
    void helpComplete(int arg0);
    protected boolean exec();
    T getRawResult();
    protected void setRawResult(T arg0);
}

class CyclicBarrier {
    CyclicBarrier(int arg0, Runnable arg1);
    CyclicBarrier(int arg0);
    int getParties();
    int await() throws InterruptedException,BrokenBarrierException;
    int await(long arg0, TimeUnit arg1) throws InterruptedException,BrokenBarrierException,TimeoutException;
    boolean isBroken();
    void reset();
    int getNumberWaiting();
}

class DelayQueue<E> extends AbstractQueue<E> implements BlockingQueue<E> {
    DelayQueue();
    DelayQueue(Collection<? extends E> arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0);
    boolean offer(E arg0, long arg1, TimeUnit arg2);
    E poll();
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E peek();
    int size();
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
    void clear();
    int remainingCapacity();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    boolean remove(Object arg0);
    Iterator<E> iterator();
}

interface Delayed extends Comparable<Delayed> {
    long getDelay(TimeUnit arg0);
}

class Exchanger<V> {
    Exchanger();
    V exchange(V arg0) throws InterruptedException;
    V exchange(V arg0, long arg1, TimeUnit arg2) throws InterruptedException,TimeoutException;
}

class ExecutionException extends Exception {
    protected ExecutionException();
    protected ExecutionException(String arg0);
    ExecutionException(String arg0, Throwable arg1);
    ExecutionException(Throwable arg0);
}

interface Executor {
    void execute(Runnable arg0);
}

class ExecutorCompletionService<V> implements CompletionService<V> {
    ExecutorCompletionService(Executor arg0);
    ExecutorCompletionService(Executor arg0, BlockingQueue<Future<V>> arg1);
    Future<V> submit(Callable<V> arg0);
    Future<V> submit(Runnable arg0, V arg1);
    Future<V> take() throws InterruptedException;
    Future<V> poll();
    Future<V> poll(long arg0, TimeUnit arg1) throws InterruptedException;
}

interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long arg0, TimeUnit arg1) throws InterruptedException;
    <T> Future<T> submit(Callable<T> arg0);
    <T> Future<T> submit(Runnable arg0, T arg1);
    Future<?> submit(Runnable arg0);
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> arg0) throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    <T> T invokeAny(Collection<? extends Callable<T>> arg0) throws InterruptedException,ExecutionException;
    <T> T invokeAny(Collection<? extends Callable<T>> arg0, long arg1, TimeUnit arg2) throws InterruptedException,ExecutionException,TimeoutException;
}

class Executors {
    static ExecutorService newFixedThreadPool(int arg0);
    static ExecutorService newWorkStealingPool(int arg0);
    static ExecutorService newWorkStealingPool();
    static ExecutorService newFixedThreadPool(int arg0, ThreadFactory arg1);
    static ExecutorService newSingleThreadExecutor();
    static ExecutorService newSingleThreadExecutor(ThreadFactory arg0);
    static ExecutorService newCachedThreadPool();
    static ExecutorService newCachedThreadPool(ThreadFactory arg0);
    static ScheduledExecutorService newSingleThreadScheduledExecutor();
    static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory arg0);
    static ScheduledExecutorService newScheduledThreadPool(int arg0);
    static ScheduledExecutorService newScheduledThreadPool(int arg0, ThreadFactory arg1);
    static ExecutorService unconfigurableExecutorService(ExecutorService arg0);
    static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService arg0);
    static ThreadFactory defaultThreadFactory();
    static ThreadFactory privilegedThreadFactory();
    static <T> Callable<T> callable(Runnable arg0, T arg1);
    static Callable<Object> callable(Runnable arg0);
    static Callable<Object> callable(PrivilegedAction<?> arg0);
    static Callable<Object> callable(PrivilegedExceptionAction<?> arg0);
    static <T> Callable<T> privilegedCallable(Callable<T> arg0);
    static <T> Callable<T> privilegedCallableUsingCurrentClassLoader(Callable<T> arg0);
}

class ForkJoinPool extends AbstractExecutorService {
    static final ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;
    ForkJoinPool();
    ForkJoinPool(int arg0);
    ForkJoinPool(int arg0, ForkJoinWorkerThreadFactory arg1, UncaughtExceptionHandler arg2, boolean arg3);
    static ForkJoinPool commonPool();
    <T> T invoke(ForkJoinTask<T> arg0);
    void execute(ForkJoinTask<?> arg0);
    void execute(Runnable arg0);
    <T> ForkJoinTask<T> submit(ForkJoinTask<T> arg0);
    <T> ForkJoinTask<T> submit(Callable<T> arg0);
    <T> ForkJoinTask<T> submit(Runnable arg0, T arg1);
    ForkJoinTask<?> submit(Runnable arg0);
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> arg0);
    ForkJoinWorkerThreadFactory getFactory();
    UncaughtExceptionHandler getUncaughtExceptionHandler();
    int getParallelism();
    static int getCommonPoolParallelism();
    int getPoolSize();
    boolean getAsyncMode();
    int getRunningThreadCount();
    int getActiveThreadCount();
    boolean isQuiescent();
    long getStealCount();
    long getQueuedTaskCount();
    int getQueuedSubmissionCount();
    boolean hasQueuedSubmissions();
    protected ForkJoinTask<?> pollSubmission();
    protected int drainTasksTo(Collection<? super ForkJoinTask<?>> arg0);
    String toString();
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isTerminated();
    boolean isTerminating();
    boolean isShutdown();
    boolean awaitTermination(long arg0, TimeUnit arg1) throws InterruptedException;
    boolean awaitQuiescence(long arg0, TimeUnit arg1);
    static void managedBlock(ManagedBlocker arg0) throws InterruptedException;
    protected <T> RunnableFuture<T> newTaskFor(Runnable arg0, T arg1);
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> arg0);
}
interface ForkJoinPool$ForkJoinWorkerThreadFactory {
    ForkJoinWorkerThread newThread(ForkJoinPool arg0);
}
interface ForkJoinPool$ManagedBlocker {
    boolean block() throws InterruptedException;
    boolean isReleasable();
}

class ForkJoinTask<V> implements Future<V>, Serializable {
    ForkJoinTask();
    ForkJoinTask<V> fork();
    V join();
    V invoke();
    static void invokeAll(ForkJoinTask<?> arg0, ForkJoinTask<?> arg1);
    static void invokeAll(ForkJoinTask<?>[] arg0);
    static <T> Collection<T> invokeAll(Collection<T> arg0);
    boolean cancel(boolean arg0);
    boolean isDone();
    boolean isCancelled();
    boolean isCompletedAbnormally();
    boolean isCompletedNormally();
    Throwable getException();
    void completeExceptionally(Throwable arg0);
    void complete(V arg0);
    void quietlyComplete();
    V get() throws InterruptedException,ExecutionException;
    V get(long arg0, TimeUnit arg1) throws InterruptedException,ExecutionException,TimeoutException;
    void quietlyJoin();
    void quietlyInvoke();
    static void helpQuiesce();
    void reinitialize();
    static ForkJoinPool getPool();
    static boolean inForkJoinPool();
    boolean tryUnfork();
    static int getQueuedTaskCount();
    static int getSurplusQueuedTaskCount();
    V getRawResult();
    protected void setRawResult(V arg0);
    protected boolean exec();
    protected static ForkJoinTask<?> peekNextLocalTask();
    protected static ForkJoinTask<?> pollNextLocalTask();
    protected static ForkJoinTask<?> pollTask();
    short getForkJoinTaskTag();
    short setForkJoinTaskTag(short arg0);
    boolean compareAndSetForkJoinTaskTag(short arg0, short arg1);
    static ForkJoinTask<?> adapt(Runnable arg0);
    static <T> ForkJoinTask<T> adapt(Runnable arg0, T arg1);
    static <T> ForkJoinTask<T> adapt(Callable<? extends T> arg0);
}

class ForkJoinWorkerThread extends Thread {
    protected ForkJoinWorkerThread(ForkJoinPool arg0);
    ForkJoinPool getPool();
    int getPoolIndex();
    protected void onStart();
    protected void onTermination(Throwable arg0);
    void run();
}

interface Future<V> {
    boolean cancel(boolean arg0);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException,ExecutionException;
    V get(long arg0, TimeUnit arg1) throws InterruptedException,ExecutionException,TimeoutException;
}

class FutureTask<V> implements RunnableFuture<V> {
    FutureTask(Callable<V> arg0);
    FutureTask(Runnable arg0, V arg1);
    boolean isCancelled();
    boolean isDone();
    boolean cancel(boolean arg0);
    V get() throws InterruptedException,ExecutionException;
    V get(long arg0, TimeUnit arg1) throws InterruptedException,ExecutionException,TimeoutException;
    protected void done();
    protected void set(V arg0);
    protected void setException(Throwable arg0);
    void run();
    protected boolean runAndReset();
}

class LinkedBlockingDeque<E> extends AbstractQueue<E> implements BlockingDeque<E>, Serializable {
    LinkedBlockingDeque();
    LinkedBlockingDeque(int arg0);
    LinkedBlockingDeque(Collection<? extends E> arg0);
    void addFirst(E arg0);
    void addLast(E arg0);
    boolean offerFirst(E arg0);
    boolean offerLast(E arg0);
    void putFirst(E arg0) throws InterruptedException;
    void putLast(E arg0) throws InterruptedException;
    boolean offerFirst(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    boolean offerLast(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E removeFirst();
    E removeLast();
    E pollFirst();
    E pollLast();
    E takeFirst() throws InterruptedException;
    E takeLast() throws InterruptedException;
    E pollFirst(long arg0, TimeUnit arg1) throws InterruptedException;
    E pollLast(long arg0, TimeUnit arg1) throws InterruptedException;
    E getFirst();
    E getLast();
    E peekFirst();
    E peekLast();
    boolean removeFirstOccurrence(Object arg0);
    boolean removeLastOccurrence(Object arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E remove();
    E poll();
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E element();
    E peek();
    int remainingCapacity();
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
    void push(E arg0);
    E pop();
    boolean remove(Object arg0);
    int size();
    boolean contains(Object arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    String toString();
    void clear();
    Iterator<E> iterator();
    Iterator<E> descendingIterator();
    Spliterator<E> spliterator();
}

class LinkedBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
    LinkedBlockingQueue();
    LinkedBlockingQueue(int arg0);
    LinkedBlockingQueue(Collection<? extends E> arg0);
    int size();
    int remainingCapacity();
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    boolean offer(E arg0);
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E poll();
    E peek();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    String toString();
    void clear();
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
    Iterator<E> iterator();
    Spliterator<E> spliterator();
}

class LinkedTransferQueue<E> extends AbstractQueue<E> implements TransferQueue<E>, Serializable {
    Spliterator<E> spliterator();
    LinkedTransferQueue();
    LinkedTransferQueue(Collection<? extends E> arg0);
    void put(E arg0);
    boolean offer(E arg0, long arg1, TimeUnit arg2);
    boolean offer(E arg0);
    boolean add(E arg0);
    boolean tryTransfer(E arg0);
    void transfer(E arg0) throws InterruptedException;
    boolean tryTransfer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E poll();
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
    Iterator<E> iterator();
    E peek();
    boolean isEmpty();
    boolean hasWaitingConsumer();
    int size();
    int getWaitingConsumerCount();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    int remainingCapacity();
}

class Phaser {
    Phaser();
    Phaser(int arg0);
    Phaser(Phaser arg0);
    Phaser(Phaser arg0, int arg1);
    int register();
    int bulkRegister(int arg0);
    int arrive();
    int arriveAndDeregister();
    int arriveAndAwaitAdvance();
    int awaitAdvance(int arg0);
    int awaitAdvanceInterruptibly(int arg0) throws InterruptedException;
    int awaitAdvanceInterruptibly(int arg0, long arg1, TimeUnit arg2) throws InterruptedException,TimeoutException;
    void forceTermination();
    int getPhase();
    int getRegisteredParties();
    int getArrivedParties();
    int getUnarrivedParties();
    Phaser getParent();
    Phaser getRoot();
    boolean isTerminated();
    protected boolean onAdvance(int arg0, int arg1);
    String toString();
}

class PriorityBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
    PriorityBlockingQueue();
    PriorityBlockingQueue(int arg0);
    PriorityBlockingQueue(int arg0, Comparator<? super E> arg1);
    PriorityBlockingQueue(Collection<? extends E> arg0);
    boolean add(E arg0);
    boolean offer(E arg0);
    void put(E arg0);
    boolean offer(E arg0, long arg1, TimeUnit arg2);
    E poll();
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E peek();
    Comparator<? super E> comparator();
    int size();
    int remainingCapacity();
    boolean remove(Object arg0);
    boolean contains(Object arg0);
    Object[] toArray();
    String toString();
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
    void clear();
    <T> T[] toArray(T[] arg0);
    Iterator<E> iterator();
    Spliterator<E> spliterator();
}

class RecursiveAction extends ForkJoinTask<Void> {
    RecursiveAction();
    protected void compute();
    Void getRawResult();
    protected void setRawResult(Void arg0);
    protected boolean exec();
}

class RecursiveTask<V> extends ForkJoinTask<V> {
    RecursiveTask();
    protected V compute();
    V getRawResult();
    protected void setRawResult(V arg0);
    protected boolean exec();
}

class RejectedExecutionException extends RuntimeException {
    RejectedExecutionException();
    RejectedExecutionException(String arg0);
    RejectedExecutionException(String arg0, Throwable arg1);
    RejectedExecutionException(Throwable arg0);
}

interface RejectedExecutionHandler {
    void rejectedExecution(Runnable arg0, ThreadPoolExecutor arg1);
}

interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}

interface RunnableScheduledFuture<V> extends RunnableFuture<V>, ScheduledFuture<V> {
    boolean isPeriodic();
}

interface ScheduledExecutorService extends ExecutorService {
    ScheduledFuture<?> schedule(Runnable arg0, long arg1, TimeUnit arg2);
    <V> ScheduledFuture<V> schedule(Callable<V> arg0, long arg1, TimeUnit arg2);
    ScheduledFuture<?> scheduleAtFixedRate(Runnable arg0, long arg1, long arg2, TimeUnit arg3);
    ScheduledFuture<?> scheduleWithFixedDelay(Runnable arg0, long arg1, long arg2, TimeUnit arg3);
}

interface ScheduledFuture<V> extends Delayed, Future<V> {
}

class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService {
    protected <V> RunnableScheduledFuture<V> decorateTask(Runnable arg0, RunnableScheduledFuture<V> arg1);
    protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> arg0, RunnableScheduledFuture<V> arg1);
    ScheduledThreadPoolExecutor(int arg0);
    ScheduledThreadPoolExecutor(int arg0, ThreadFactory arg1);
    ScheduledThreadPoolExecutor(int arg0, RejectedExecutionHandler arg1);
    ScheduledThreadPoolExecutor(int arg0, ThreadFactory arg1, RejectedExecutionHandler arg2);
    ScheduledFuture<?> schedule(Runnable arg0, long arg1, TimeUnit arg2);
    <V> ScheduledFuture<V> schedule(Callable<V> arg0, long arg1, TimeUnit arg2);
    ScheduledFuture<?> scheduleAtFixedRate(Runnable arg0, long arg1, long arg2, TimeUnit arg3);
    ScheduledFuture<?> scheduleWithFixedDelay(Runnable arg0, long arg1, long arg2, TimeUnit arg3);
    void execute(Runnable arg0);
    Future<?> submit(Runnable arg0);
    <T> Future<T> submit(Runnable arg0, T arg1);
    <T> Future<T> submit(Callable<T> arg0);
    void setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean arg0);
    boolean getContinueExistingPeriodicTasksAfterShutdownPolicy();
    void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean arg0);
    boolean getExecuteExistingDelayedTasksAfterShutdownPolicy();
    void setRemoveOnCancelPolicy(boolean arg0);
    boolean getRemoveOnCancelPolicy();
    void shutdown();
    List<Runnable> shutdownNow();
    BlockingQueue<Runnable> getQueue();
}

class Semaphore implements Serializable {
    Semaphore(int arg0);
    Semaphore(int arg0, boolean arg1);
    void acquire() throws InterruptedException;
    void acquireUninterruptibly();
    boolean tryAcquire();
    boolean tryAcquire(long arg0, TimeUnit arg1) throws InterruptedException;
    void release();
    void acquire(int arg0) throws InterruptedException;
    void acquireUninterruptibly(int arg0);
    boolean tryAcquire(int arg0);
    boolean tryAcquire(int arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    void release(int arg0);
    int availablePermits();
    int drainPermits();
    protected void reducePermits(int arg0);
    boolean isFair();
    boolean hasQueuedThreads();
    int getQueueLength();
    protected Collection<Thread> getQueuedThreads();
    String toString();
}

class SynchronousQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {
    SynchronousQueue();
    SynchronousQueue(boolean arg0);
    void put(E arg0) throws InterruptedException;
    boolean offer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    boolean offer(E arg0);
    E take() throws InterruptedException;
    E poll(long arg0, TimeUnit arg1) throws InterruptedException;
    E poll();
    boolean isEmpty();
    int size();
    int remainingCapacity();
    void clear();
    boolean contains(Object arg0);
    boolean remove(Object arg0);
    boolean containsAll(Collection<?> arg0);
    boolean removeAll(Collection<?> arg0);
    boolean retainAll(Collection<?> arg0);
    E peek();
    Iterator<E> iterator();
    Spliterator<E> spliterator();
    Object[] toArray();
    <T> T[] toArray(T[] arg0);
    int drainTo(Collection<? super E> arg0);
    int drainTo(Collection<? super E> arg0, int arg1);
}

interface ThreadFactory {
    Thread newThread(Runnable arg0);
}

class ThreadLocalRandom extends Random {
    static ThreadLocalRandom current();
    void setSeed(long arg0);
    protected int next(int arg0);
    int nextInt();
    int nextInt(int arg0);
    int nextInt(int arg0, int arg1);
    long nextLong();
    long nextLong(long arg0);
    long nextLong(long arg0, long arg1);
    double nextDouble();
    double nextDouble(double arg0);
    double nextDouble(double arg0, double arg1);
    boolean nextBoolean();
    float nextFloat();
    double nextGaussian();
    IntStream ints(long arg0);
    IntStream ints();
    IntStream ints(long arg0, int arg1, int arg2);
    IntStream ints(int arg0, int arg1);
    LongStream longs(long arg0);
    LongStream longs();
    LongStream longs(long arg0, long arg1, long arg2);
    LongStream longs(long arg0, long arg1);
    DoubleStream doubles(long arg0);
    DoubleStream doubles();
    DoubleStream doubles(long arg0, double arg1, double arg2);
    DoubleStream doubles(double arg0, double arg1);
}

class ThreadPoolExecutor extends AbstractExecutorService {
    // TODO: arg2 should have same units as arg3
    ThreadPoolExecutor(int arg0, int arg1, @UnknownUnits long arg2, @UnknownUnits TimeUnit arg3, BlockingQueue<Runnable> arg4);
    ThreadPoolExecutor(int arg0, int arg1, @UnknownUnits long arg2, @UnknownUnits TimeUnit arg3, BlockingQueue<Runnable> arg4, ThreadFactory arg5);
    ThreadPoolExecutor(int arg0, int arg1, @UnknownUnits long arg2, @UnknownUnits TimeUnit arg3, BlockingQueue<Runnable> arg4, RejectedExecutionHandler arg5);
    ThreadPoolExecutor(int arg0, int arg1, @UnknownUnits long arg2, @UnknownUnits TimeUnit arg3, BlockingQueue<Runnable> arg4, ThreadFactory arg5, RejectedExecutionHandler arg6);
    void execute(Runnable arg0);
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminating();
    boolean isTerminated();
    boolean awaitTermination(@UnknownUnits long arg0, @UnknownUnits TimeUnit arg1) throws InterruptedException;
    protected void finalize();
    void setThreadFactory(ThreadFactory arg0);
    ThreadFactory getThreadFactory();
    void setRejectedExecutionHandler(RejectedExecutionHandler arg0);
    RejectedExecutionHandler getRejectedExecutionHandler();
    void setCorePoolSize(int arg0);
    int getCorePoolSize();
    boolean prestartCoreThread();
    int prestartAllCoreThreads();
    boolean allowsCoreThreadTimeOut();
    void allowCoreThreadTimeOut(boolean arg0);
    void setMaximumPoolSize(int arg0);
    int getMaximumPoolSize();
    void setKeepAliveTime(@UnknownUnits long arg0, @UnknownUnits TimeUnit arg1);
    long getKeepAliveTime(@UnknownUnits TimeUnit arg0);
    BlockingQueue<Runnable> getQueue();
    boolean remove(Runnable arg0);
    void purge();
    int getPoolSize();
    int getActiveCount();
    int getLargestPoolSize();
    long getTaskCount();
    long getCompletedTaskCount();
    String toString();
    protected void beforeExecute(Thread arg0, Runnable arg1);
    protected void afterExecute(Runnable arg0, Throwable arg1);
    protected void terminated();
}
class ThreadPoolExecutor$CallerRunsPolicy implements RejectedExecutionHandler {
    CallerRunsPolicy();
    void rejectedExecution(Runnable arg0, ThreadPoolExecutor arg1);
}
class ThreadPoolExecutor$AbortPolicy implements RejectedExecutionHandler {
    AbortPolicy();
    void rejectedExecution(Runnable arg0, ThreadPoolExecutor arg1);
}
class ThreadPoolExecutor$DiscardPolicy implements RejectedExecutionHandler {
    DiscardPolicy();
    void rejectedExecution(Runnable arg0, ThreadPoolExecutor arg1);
}
class ThreadPoolExecutor$DiscardOldestPolicy implements RejectedExecutionHandler {
    DiscardOldestPolicy();
    void rejectedExecution(Runnable arg0, ThreadPoolExecutor arg1);
}


class TimeoutException extends Exception {
    TimeoutException();
    TimeoutException(String arg0);
}

interface TransferQueue<E> extends BlockingQueue<E> {
    boolean tryTransfer(E arg0);
    void transfer(E arg0) throws InterruptedException;
    boolean tryTransfer(E arg0, long arg1, TimeUnit arg2) throws InterruptedException;
    boolean hasWaitingConsumer();
    int getWaitingConsumerCount();
}
